//
//  {{ prefix }}{{ module_info.name }} - {{ module_info.file_name }}
//  {{ module_info.project_name }}
//
//  Created by {{ developer.name }} on {{ date }}.
//  Copyright Â© {{ year }} {{ developer.company }}. All rights reserved.
//
import Foundation
import Swinject

// swiftlint:disable force_cast line_length identifier_name
class {{ module_info.name }}Module {
    fileprivate(set) var assembler: Assembler?
    fileprivate(set) var view: {{ module_info.name }}ViewController?
    weak fileprivate(set) var input: {{ module_info.name }}ModuleInput?
    static func assemble(root: Assembler?, output: {{ module_info.name }}ModuleOutput? = nil) -> {{ module_info.name }}Module {
        let assembler = Assembler([
            {{ module_info.name }}InteractorAssembly(),
            {{ module_info.name }}RouterAssembly(),
            {{ module_info.name }}PresenterAssembly(),
            {{ module_info.name }}ViewAssembly(),
            {{ module_info.name }}ModuleAssembly()
            ], parent: root)
        return assembler.resolver.resolve( {{ module_info.name }}Module.self, arguments: assembler, output )!
    }
}

private class {{ module_info.name }}InteractorAssembly: Assembly {
    func assemble(container: Container) {
    	// argument Bool if persists, means that need to create-only object,
    	// without resolving properties.
    	// used in {{ module_info.name }}ModuleAssembly's `assemble(container:)`
    	// because there it resolving properties by self avoiding cycles
        container.register({{ module_info.name }}Interactor.self) { (_, _: Bool) in
            return {{ module_info.name }}Interactor()
        }
        // If call resolve without argument
        // will automatically resolve properties at initCompleted
        container.register({{ module_info.name }}Interactor.self) { r in
            return r.resolve( {{ module_info.name }}Interactor.self, argument: true )!
        }.initCompleted { r, interactor in
            interactor.output = r.resolve()
        }

        container.register({{ module_info.name }}InteractorInput.self) { r in
            return r.resolve( {{ module_info.name }}Interactor.self )!
        }
    }
}

private class {{ module_info.name }}RouterAssembly: Assembly {
    func assemble(container: Container) {
        // argument Bool if persists, means that need to create-only object,
    	// without resolving properties.
    	// used in {{ module_info.name }}ModuleAssembly's `assemble(container:)`
    	// because there it resolving properties by self avoiding cycles
        container.register({{ module_info.name }}Router.self) { (_, _: Bool) in
            return {{ module_info.name }}Router()
        }
        // If call resolve without argument
        // will automatically resolve properties at initCompleted
        container.register({{ module_info.name }}Router.self) { r in
            return  r.resolve( {{ module_info.name }}Router.self, argument: true )!
        }.initCompleted { (r, router) in
            router.transitionHandler = r.resolve()
        }

        container.register({{ module_info.name }}Router.self) { (r, assembler: Assembler) in
            let router = r.resolve({{ module_info.name }}Router.self)!
            router.assembler = assembler
            return router
        }

        container.register({{ module_info.name }}RouterInput.self) { r in
            return r.resolve( {{ module_info.name }}Router.self )!
        }
    }
}

private class {{ module_info.name }}PresenterAssembly: Assembly {
    func assemble(container: Container) {
    	// used in {{ module_info.name }}ModuleAssembly's `assemble(container:)`
    	// because there it resolving properties by self avoiding cycles
        container.register({{ module_info.name }}Presenter.self) { (_, output: {{ module_info.name }}ModuleOutput?, interactorInput: {{ module_info.name }}InteractorInput, routerInput: {{ module_info.name }}RouterInput) in
            let presenter = {{ module_info.name }}Presenter(interactorInput: interactorInput, routerInput: routerInput)
            presenter.output = output
            return presenter
        }
        // If call resolve without argument
        // will automatically resolve properties at initCompleted
        container.register({{ module_info.name }}Presenter.self) { r in
        	let moduleOutput: {{ module_info.name }}ModuleOutput? = nil // need to send nil as concrete type
            return r.resolve( {{ module_info.name }}Presenter.self, arguments: moduleOutput, r.resolve( {{ module_info.name }}InteractorInput.self )!, r.resolve( {{ module_info.name }}RouterInput.self )! )!
        }.initCompleted { (r, presenter) in
            presenter.view = r.resolve()
        }

        container.register({{ module_info.name }}ModuleInput.self) { r in
            return r.resolve( {{ module_info.name }}Presenter.self )!
        }

        container.register({{ module_info.name }}InteractorOutput.self) { r in
            return r.resolve( {{ module_info.name }}Presenter.self )!
        }

        container.register({{ module_info.name }}ViewOutput.self) { r in
            return r.resolve( {{ module_info.name }}Presenter.self )!
        }
    }
}

private class {{ module_info.name }}ViewAssembly: Assembly {
    func assemble(container: Container) {
    	container.register({{ module_info.name }}ViewController.self) { (_, viewOutput: {{ module_info.name }}ViewOutput) in
            return {{ module_info.name }}ViewController(viewOutput: viewOutput)
        }

        container.register({{ module_info.name }}ViewController.self) { r in
            return r.resolve( {{ module_info.name }}ViewController.self, argument: r.resolve( {{ module_info.name }}ViewOutput.self )! )!
        }

        container.register({{ module_info.name }}ViewInput.self) { r in
            return r.resolve( {{ module_info.name }}ViewController.self )!
        }

        container.register({{ module_info.name }}TransitionHandler.self) { r in
            return r.resolve( {{ module_info.name }}ViewController.self )!
        }
    }
}

private class {{ module_info.name }}ModuleAssembly: Assembly {
    func assemble(container: Container) {
        container.register({{ module_info.name }}Module.self, factory: { (r, assembler: Assembler, output: {{ module_info.name }}ModuleOutput?) in
        	// create only object without resolving properties
        	let interactor = r.resolve( {{ module_info.name }}Interactor.self, argument: true )!
        	// create only object without resolving properties
            let router = r.resolve( {{ module_info.name }}Router.self, argument: true )!
            router.assembler = assembler

            let presentener = r.resolve( {{ module_info.name }}Presenter.self, arguments: output, interactor as {{ module_info.name }}InteractorInput, router as {{ module_info.name }}RouterInput )!
			interactor.output = presentener

            let view = r.resolve( {{ module_info.name }}ViewController.self, argument: presentener as {{ module_info.name }}ViewOutput)
            router.transitionHandler = view
            presentener.view = view

            let module: {{ module_info.name }}Module = {{ module_info.name }}Module()
            module.view = view
            module.input = presentener
            module.assembler = assembler
            return module
        })
    }
}
// swiftlint:enable force_cast line_length identifier_name
